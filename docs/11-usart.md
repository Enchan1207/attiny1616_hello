# usart

## Overview

本稿では、ATtiny1616でUSARTを制御するための要点を整理します。対応するソースコードは `src/usart_hello` にあります。

## USARTペリフェラルの利用

### 初期化

データシート _24.3.1 初期化_ によれば、

> 1. TxD ピンの値を HIGH に設定し、必要に応じて XCK ピンを LOW に設定します(PORT.OUT 内のOUT[n])。
> 2. TxD ピン(および必要に応じて XCK ピン)を出力として設定します(PORT.DIR 内の DIR[n])。
> 3. baud レート(USART.BAUD)とフレーム フォーマットを設定します。
> 4. 動作モードを設定します(XCK ピン出力を同期モードで有効にします)。
> 5. 用途に応じてトランスミッタまたはレシーバを有効にします。
>
> 割り込み駆動による USART 動作のため、初期化中はグローバル割り込みを無効にする必要があります。

また _24.5.7 制御 B_ によれば、

> Bit 6 – TXEN: トランスミッタ イネーブル
> このビットに「1」を書き込む事で USART トランスミッタを有効にします。
> 有効にされたトランスミッタは、TxD ピンの通常のポート動作を上書きします。トランスミッタの無効化(TXEN への「0」の書き込み)は、実行中および保留中の送信が完了するまで(すなわち、送信シフトレジスタと送信バッファレジスタが送信データを格納している限り) 実行されません。
> 無効にされたトランスミッタは、TxD ポートを上書きしません。

さらに _24.5.10 baud レートレジスタ_ によれば、

> USART.BAUDL および USART.BAUDH レジスタペアにより、16 ビット値 USART.BAUD を形成します。

これに加え _表 24-2. baud レートレジスタ設定値の計算式_ を参照し……

USARTの基本的な初期化コードは以下のようになります。

```c
#define UART_TX_PIN 2  // PB2
#define BAUD_RATE 115200
#define USART_BAUD_RATE(BAUD_RATE) ((float)(F_CPU * 64 / (16 * (float)BAUD_RATE)) + 0.5)

void uart_init(void) {
    PORTB.DIRSET = (1 << UART_TX_PIN);
    USART0.BAUD = (uint16_t)USART_BAUD_RATE(BAUD_RATE);
    USART0.CTRLB = USART_TXEN_bm;
}
```

### 送信

データシート _24.3.2.3 データ送信 - USART トランスミッタ_ によれば、

> データ送信は、送信バッファ(USART.TXDATA 内の DATA)に送信するデータを書き込む事によって開始します。
> 送信バッファ内のデータは、シフトレジスタがエンプティになって次のフレームの送信準備が完了した時点でシフトレジスタへ転送されます。シフトレジスタは、アイドルステート中(実行中の送信なし)の場合に書き込まれるか、直前のフレームの最後のストップビットが送信された直後に書き込まれます。シフトレジスタにデータが書き込まれると、1 つの完全なフレームが送信されます。
> シフトレジスタ内のフレームが完全にシフトアウトされた時、送信バッファに新しいデータが格納されていなければ、送信完了割り込みフラグ(USART.STATUS 内の TXCIF) がセットされ、有効にされていれば割り込みが生成されます。
> TXDATA は、データレジスタ エンプティフラグ(USART.STATUS 内の DREIF) がセットされている時にのみ書き込み可能です。このフラグは、レジスタがエンプティであり新しいデータの書き込みが可能である事を示します。

すなわち、単一バイトを送信する関数は以下のようになります。

```c
void uart_send(uint8_t data) {
    while(!(USART0.STATUS & USART_DREIF_bm));
    USART0.TXDATAL = data;
}
```

ここまでの内容をまとめたコードは `usart_hello/main.c` に示しています。
