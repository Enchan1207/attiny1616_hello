# blink

## Overview

本稿では、ATtiny1616でLチカを実現するための要点を整理します。対応するソースコードは `src/blink` にあります。

## ポート操作

従来のAVRは `PORTx`, `DDRx`, `PINx` の3レジスタを持っていました:

```c
#include <avr/io.h>
#include <util/delay.h>

int main(){
    // ポートBの方向を出力に設定し、全ピンのレベルをLにする
    DDRB = 0xFF;
    PORTB = 0x00;

    while(1){
        PORTB ^= 0xFF;
        _delay_ms(1000);
    }
}
```

tinyAVR 1ではAPIが整理され、構造体 `PORT_t` を介してアクセスできるようになりました。
`DDRx` は `PORTx.DIR` に、`PORTx` は `PORTx.OUT` に、`PINx` は `PORTx.IN` にそれぞれ対応します。

また `DIR`, `OUT` にはそれぞれ `xxxSET`, `xxxCLR` が存在します。対応するビットを立てるとセットまたはクリアされます。

これを踏まえると、基本的なLチカはこのように書くことができます:

```c
#include <avr/io.h>
#include <util/delay.h>

// PA7にLEDを接続した想定
PORT_t* const port = &PORTA;
const uint8_t pin = 7;

int main() {
    port->DIR |= (1 << pin);
    port->OUT &= ~(1 << pin);

    while (1) {
        port->OUT ^= (1 << pin);
        _delay_ms(1000);
    }
}
```

しかし、これを(工場出荷時のMCUへ)書き込んで動作させるとだいぶゆっくり点滅します。
1000ms = 1sec待機しているので、2秒周期でオン・オフを繰り返すはずですが、実際は12秒程度の間隔で点滅します。

## クロック設定

この問題はクロック源の設定に起因しています。

### 電源投入時の動作

データシート _10.3.2 メインクロックの選択とプリスケーラ_ によれば、

> 全ての内部オシレータは、`CLK_MAIN` 向けのメインクロック源として使えます。メインクロック源はソフトウェアから選択でき、通常動作中に安全に切り換える事ができます。
>
> `CLK_MAIN` は、プリスケーラを経由した後に、デバイス内の周辺モジュール(`CLK_PER`)によって使われます。プリスケーラは `CLK_MAIN` を 1～64 分周します。
> メインクロックおよびプリスケーラ コンフィグレーション レジスタ(`CLKCTRL.MCLKCTRLA`、`CLKCTRL.MCLKCTRLB`)は設定変更保護機能(CCP)により保護されています。これらのレジスタを変更するには、時限付きの書き込み手順が必要です。

また _10.3.3 リセット後のメインクロック_ によれば、

> 全てのタイプのリセット後に、`CLK_MAIN` は 16/20 MHz オシレータ(`OSC20M`)と分周比 6 のプリスケーラによって供給されます。
> `OSC20M` の実際の周波数はオシレータ コンフィグレーション ヒューズ(`FUSE.OSCCFG`)の周波数選択ビット(`FREQSEL`)によって決まります。

さらに _10.5.2 メインクロック制御 B_ によれば、

> 名称:  MCLKCTRLB
> オフセット: 0x01
> リセット:  0x11
>
> Bit 4:1 – PDIV[3:0]: プリスケーラ分周比
> Bit 0 – PEN: プリスケーラ イネーブル

すなわち、

- ATtiny1616のクロック源は `CLK_MAIN` であり、
- 設定可能なプリスケーラを通過し、
- その値はリセット直後に6である

ということです。

内蔵20MHzオシレータを6分周するということは、 `_delay_ms(1000)` で6秒待機することになります。
先述した _実際は12秒程度の間隔で点滅_ というのは、この値からきています。

### 設定変更

プリスケーラの設定を変更するにはレジスタ `MCLKCTRLB` に値を書き込めばokです。

今回はプリスケーラを通さず `CLK_MAIN` をそのまま投入し、20MHzで動作させるため……
設定変更はこのようなコードで行うことができそうです(定数を使うと便利)。

```c
CLKCTRL_MCLKCTRLB = CLKCTRL_PDIV_0_bm | CLKCTRL_PEN_bm;
```

しかし先述の通りこのレジスタは _設定変更保護機能(CCP)により保護されてい_ るため、これを解除する必要があります。

データシート _8.5.7 CCP - 設定変更保護_ によれば、

> システムの重要 I/O レジスタの設定は、偶発的な変更から保護されます。フラッシュ自己書き込み(NVMコントローラへのストアによる)も、偶発的な実行から保護されます。これらの保護機能は、設定変更保護(`CCP`)レジスタにより、グローバルに処理されます。
> 保護された I/O レジスタまたはビットに対する変更、または保護された命令の実行は、CPU が `CCP` レジスタにシグネチャを書き込んだ後でのみ可能です。これらのシグネチャは、`CCP` レジスタ(`CPU.CCP`)の説明に記載しています。
> 動作モードには 2 種類(保護された I/O レジスタのモードと、保護された自己書き込みのモード)があります。

また _8.5.7.1 設定変更保護された I/O レジスタへの書き込み動作シーケンス_ によれば、

> CCP によって保護されたレジスタに書き込むための手順は以下の通りです。
>
> 1. ソフトウェアにより、CPU.CCP レジスタの CCP ビットフィールドに、保護された I/O レジスタの変更を許可するためのシグネチャを書き込みます。
> 2. ソフトウェアは、4 命令サイクル以内に保護されたレジスタにデータを書き込む必要があります。
>
> 大部分の保護されたレジスタは、書き込みイネーブル/変更イネーブル/ロックビットも格納しています。このビットには、データの書き込みと同じ動作で「1」を書き込む必要があります。
>
> 設定変更が可能な期間は、次の場合に即座に終了します:
>
> 1) CPU が I/O レジスタまたはデータメモリに書き込んだ場合、
> 2) フラッシュ、NVMCTRL、EEPROM へのロードまたはストア アクセスが実行された場合、
> 3) SLEEP 命令が実行された場合。

また _8.7.1 設定変更保護_ によれば、

> Bit 7:0 – CCP[7:0]: 設定変更保護
>
> このビットフィールドに適切なシグネチャを書き込むと、次の 4 CPU 命令サイクル中に、保護されたI/O レジスタの変更または保護された命令の実行が許可されます。
> この 4 命令サイクル中は全てりの割込みが無視されます。その後、割り込みは自動的に CPU によって処理されます。保留中の全ての割り込みは、優先レベルと同レベル内優先順位に従って実行されます。
> 保護された I/O レジスタ向けのシグネチャが書き込まれると、CCP 機能が有効な間は CCP[0]が「1」として読み出されます。
> 自己書き込み向けのシグネチャが書き込まれると、CCP 機能が有効な間は CCP[1]が「1」として読み出されます。
>
> 0xD8 IOREG 保護された I/O レジスタの変更を許可する

すなわち、レジスタ `MCLKCTRLB` を書き換える直前でレジスタ `CCP` に `0xD8` を書き込む必要がある……ということです。

ここまでの内容をまとめたコードは `blink/main.c` に示しています。
